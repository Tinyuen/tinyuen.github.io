<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tinyuen 是小虎啊 🐯</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianxiaohu.online/"/>
  <updated>2021-08-09T06:35:13.236Z</updated>
  <id>https://tianxiaohu.online/</id>
  
  <author>
    <name>Tinyuen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 中各种实现 Refs 的方式总结</title>
    <link href="https://tianxiaohu.online/2020/05/29/front-end/react/react-refs/"/>
    <id>https://tianxiaohu.online/2020/05/29/front-end/react/react-refs/</id>
    <published>2020-05-29T23:11:38.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>在常规的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改子元素，你需要用新的 props 去重新渲染子元素。然而，在少数情况下，你需要在常规数据流外强制修改子元素。被修改的子元素可以是 React 组件实例，或者是一个 DOM 元素。在这种情况下，React 提供了解决办法。文章中会讲到 <code>React.useRef</code>、<code>React.createRef</code>、<code>React.forwardRef</code>、<code>回调 Refs</code> 相关知识。</p><a id="more"></a><p>你可能首先会想到在你的应用程序中使用 <code>Refs</code> 来更新组件。如果是这种情况，请花一点时间，想想是不是可以通过 <code>state</code> 的方式来实现，React 不建议过多的使用 <code>Refs</code>。<code>Refs</code> 会使组件的实例或者是DOM结构暴露，违反组件封装的原则。</p><p>但是有些场景下这会非常有用：</p><ul><li>处理focus、文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方DOM库</li></ul><p>React 中不同的版本都提供了不同的 <code>Refs</code> 使用方式，今天来总结下。</p><h2 id="React-useRef"><a href="#React-useRef" class="headerlink" title="React.useRef"></a>React.useRef</h2><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。也就是说，以往无“状态的”函数式组件，现在也可以“有状态”了！，具体详见 React 的官方文档介绍，这里不做展开。</p><p>我们先看一段代码：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `inputEl.current` 指向已挂载到 DOM 上的文本输入元素</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; <span class="keyword">type</span>=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>useRef</code> 就是 React 新特性中提供的一种 <code>Hooks</code>（<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">Hooks API 索引</a>）。</p><p>useRef 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）。返回的 <code>ref</code> 对象在组件的整个生命周期内保持不变。这里 React 通过 <code>useRef</code> 方法返回的 <code>inputEl</code> 传入 <code>input</code> 的 <code>ref</code> 属性，用来指向真实的DOM元素。</p><p>当然 <code>useRef</code> 的作用不止于此….</p><h2 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef"></a>React.createRef</h2><p>使用 <code>React.createRef()</code> 创建 <code>refs</code>，通过 <code>ref</code> 属性来获得 React 元素。当构造组件时，<code>refs</code> 通常被赋值给实例的一个属性，这样你可以在组件中任意一处使用它们。当一个 <code>ref</code> 属性被传递给一个 <code>render</code> 函数中的元素时，可以使用 <code>ref</code> 中的 <code>current</code> 属性对节点的引用进行访问。</p><p>我们来看一段代码：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TextInput <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 创建一个 ref</span></span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focusTextInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input <span class="keyword">type</span>=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          <span class="keyword">type</span>=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Focus the text input"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.focusTextInput&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>React.createRef()</code> 创建了一个 ref 赋值给 <code>this.textInput</code>，传入 <code>input</code> 的 ref 属性，此时 <code>this.textInput.current</code> 将会拿到 input 的真实的 DOM，用来直接操作 DOM。React 组件在加载时将 DOM 元素传入 ref 的回调函数，在卸载时则会传入 null。</p><h2 id="为类（Class）组件添加-Ref"><a href="#为类（Class）组件添加-Ref" class="headerlink" title="为类（Class）组件添加 Ref"></a>为类（Class）组件添加 Ref</h2><p>以上面的 Class 组件 <code>TextInput</code> 为基础组件，我们再来添加一个父组件：</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoFocusTextInput <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.current.focusTextInput();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;TextInput ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式 <code>this.textInput.current</code> 将会引用到 <code>TextInput</code> 子组件的实例对象。用来调用子组件的方法。</p><p>需要注意的是，这种方法仅对以类(class)声明的 TextInput 有效！因为 Class 组件才会有实例对象。</p><h2 id="为函数式（Functional）组件添加-Ref"><a href="#为函数式（Functional）组件添加-Ref" class="headerlink" title="为函数式（Functional）组件添加 Ref"></a>为函数式（Functional）组件添加 Ref</h2><p>因为 ref 属性只能用在 Class 组件上，所以下面这样使用将会是无效的。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionalInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;input /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Parent <span class="keyword">extends</span> React.Component &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// This will *not* work!</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;FunctionalInput ref=&#123;<span class="keyword">this</span>.textInput&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那函数式组件如何使用 Ref 呢？ 我看看一段代码:</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionalInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// textInput 用来存储 ref</span></span><br><span class="line">  <span class="keyword">let</span> textInput = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input <span class="keyword">type</span>=<span class="string">"text"</span> ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> textInput = input&#125; /&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        <span class="keyword">type</span>=<span class="string">"button"</span></span><br><span class="line">        value=<span class="string">"Focus the text input"</span></span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>React 将在组件挂载时将 input 的 DOM 元素传入 ref 回调函数并调用，这样 <code>textInput</code> 就会拿到 input 的DOM 引用。当卸载时会传入 null 并调用它该回调函数。</p><h2 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h2><p>回调 Ref 也是一种设置 <code>Refs</code> 的方式。ref 属性将会接受一个回调函数，这个函数接受 React 组件的实例或 HTML DOM 元素作为参数，以存储它们并使它们能被其他地方访问。</p><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionalInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.textInput = null;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  setInputRef = (el) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.textInput = el;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 渲染后文本框自动获得焦点</span></span><br><span class="line"><span class="regexp">    this.textInput.focus();</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;FunctionalInput inputRef=&#123;this.setInputRef&#125; /</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Parent 传递给它的 ref 回调函数作为 inputRef 传递给 FunctionalInput，然后 FunctionalInput 通过 ref 属性将其传递给 <code>&lt;input&gt;</code>。最终，Parent 中的 this.textInput 将被设置为与 FunctionalInput 中的 <code>&lt;input&gt;</code> 元素相对应的 DOM 节点。</p><h2 id="暴露子组件的-DOM-节点"><a href="#暴露子组件的-DOM-节点" class="headerlink" title="暴露子组件的 DOM 节点"></a>暴露子组件的 DOM 节点</h2><p>某些特殊的情况下，我们可能会需要在父组件中获取到子组件的某个DOM节点。正常情况下，如果是自定义组件，我们通过 Refs 的获取方式获取到的一般是组件的实例对象，如果仅仅是希望获取到子组件的 DOM 节点，那么 <code>React.forwardRef</code> 将会帮上你的忙，前提是需要在 16.3 以上的版本。甚至搭配 <code>useImperativeMethods</code> 将会更完美。详见另一篇文章：<a href="">React 的 Refs 转发 React.forwardRef</a> 。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在常规的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改子元素，你需要用新的 props 去重新渲染子元素。然而，在少数情况下，你需要在常规数据流外强制修改子元素。被修改的子元素可以是 React 组件实例，或者是一个 DOM 元素。在这种情况下，React 提供了解决办法。文章中会讲到 &lt;code&gt;React.useRef&lt;/code&gt;、&lt;code&gt;React.createRef&lt;/code&gt;、&lt;code&gt;React.forwardRef&lt;/code&gt;、&lt;code&gt;回调 Refs&lt;/code&gt; 相关知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
      <category term="React" scheme="https://tianxiaohu.online/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>URL.createObjectURL 实现本地图片预览</title>
    <link href="https://tianxiaohu.online/2020/04/05/front-end/javascript/image-preview/"/>
    <id>https://tianxiaohu.online/2020/04/05/front-end/javascript/image-preview/</id>
    <published>2020-04-05T23:30:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>本地图片预览应该算是一个比较常见的需求，无需依赖服务端返回图片的地址，前端可以直接在本地预览图片。<br> <a id="more"></a></p><p>本地图片预览应该算是一个比较常见的需求，无需依赖服务端返回图片的地址，前端可以直接在本地预览图片。比较常见的就是使用 HTML5 的 FileReader API 来实现，但是今天我们介绍另外一种实现方式。使用 URL.createObjectURL 来实现。</p><h2 id="何为-createObjectURL"><a href="#何为-createObjectURL" class="headerlink" title="何为 createObjectURL"></a>何为 createObjectURL</h2><p><code>URL.createObjectURL()</code> 静态方法会创建一个 <code>DOMString</code>，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 <code>File</code> 对象或 <code>Blob</code> 对象。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectURL = URL.createObjectURL(object);</span><br></pre></td></tr></table></figure><p>object：用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。​</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下示例代码都是精简过的代码，只包含关键部分。实际项目中使用可以使用自己喜欢的方式封装，以达到更好的复用性。</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./image-previewer.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文件选择--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--显示预览的图片--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    imgPreviewer();  </span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>image-previewer.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">imgPreviewer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).onchange = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> createObjectURL = <span class="function"><span class="keyword">function</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>[<span class="built_in">window</span>.webkitURL ? <span class="string">'webkitURL'</span> : <span class="string">'URL'</span>][<span class="string">'createObjectURL'</span>](blob);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> imgDta = createObjectURL(ele);</span><br><span class="line">    <span class="keyword">var</span> pvImg = <span class="keyword">new</span> Image();</span><br><span class="line">    pvImg.src = imgDta;</span><br><span class="line">    pvImg.setAttribute(<span class="string">'id'</span>, <span class="string">'previewImg'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).innerHTML = <span class="string">''</span>;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>).appendChild(pvImg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是代码的关键部分，只保留的精简的逻辑。在实际项目中使用时候，需要增加一些容错的判断，比如文件的后缀名判断，或者文件大小的限制等等。大家自行补全即可。</p><p>文件本地预览还有一个比较方便的 API 就是 <code>FileReader</code>，大家可以去看下，使用也是比较简单的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地图片预览应该算是一个比较常见的需求，无需依赖服务端返回图片的地址，前端可以直接在本地预览图片。&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何为已经安装好的 Nginx 添加 SSL 模块</title>
    <link href="https://tianxiaohu.online/2020/03/21/server-end/nginx/nginx-add-ssl-module/"/>
    <id>https://tianxiaohu.online/2020/03/21/server-end/nginx/nginx-add-ssl-module/</id>
    <published>2020-03-21T20:36:46.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>一般在默认安装 Nginx 的时候，<code>http_ssl_module</code> 模块一般是不会安装的。但是当我们需要在 Nginx 中配置 SSL 的时候，这个模块是必须要安装的。如果配置 SSL 的时候之前没有安装过这个模块，那么不需要重装 Nginx，也是有办法配置这个模块的。接下来就来讲讲怎么在已经安装完的 Nginx 中添加 <code>http_ssl_module</code> 模块。</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在开始前，你需要确保你已经知道你的 Nginx 的一些配置信息。比如安装目录、安装包所在目录。以下是我自己的路径：</p><ul><li>Nginx 版本：<strong>1.12.0</strong></li><li>Nginx 安装包目录：<strong>/home/gym/data/nginx/nginx-1.12.0</strong></li><li>Nginx 安装路径：<strong>/usr/local/nginx</strong></li></ul><h3 id="检查自己-Nginx-版本以及编译信息"><a href="#检查自己-Nginx-版本以及编译信息" class="headerlink" title="检查自己 Nginx 版本以及编译信息"></a>检查自己 Nginx 版本以及编译信息</h3><p>首先运行如下命令查看自己 Nginx 的编译信息。前边的 <code>/usr/local/nginx</code> 就是你本地 Nginx <strong>安装目录</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure><p>然后你会得到类似如下的信息：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nginx version: nginx/1.12.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) </span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure><p>以上信息着重注意：<code>--prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code> 这个就是我们 Nginx 的编译时候的参数。</p><p>因为我已经安装过了 <code>http_ssl_module</code> 模块，所以 <code>configure arguments</code> 中已经有了。</p><h3 id="进入-Nginx-安装目录"><a href="#进入-Nginx-安装目录" class="headerlink" title="进入 Nginx 安装目录"></a>进入 Nginx 安装目录</h3><p>通过命令进入到自己 Nginx 的安装包的目录，（注意这个目录是你自己机器上的安装目录）</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/gym/data/nginx/nginx-1.12.0</span><br></pre></td></tr></table></figure><h3 id="重新编译-Nginx"><a href="#重新编译-Nginx" class="headerlink" title="重新编译 Nginx"></a>重新编译 Nginx</h3><p>在 Nginx 的安装目录里面，执行如下命令。<code>--prefix</code> 是代表的 Nginx 的安装目录，后面的 <code>--with-</code> 是代表的目前的编译参数。以前的参数要记得复制下来，然后在这个参数基础上增加 ssl 模块需要的参数 <code>--with-http_ssl_module</code> </p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure><h3 id="make-编译"><a href="#make-编译" class="headerlink" title="make 编译"></a>make 编译</h3><p>执行 make 命令编译 Nginx，make 完之后在 objs 目录下就多了个 nginx。这个就是我们新的 Nginx 程序。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="备份原-Nginx，用刚生成的覆盖老的"><a href="#备份原-Nginx，用刚生成的覆盖老的" class="headerlink" title="备份原 Nginx，用刚生成的覆盖老的"></a>备份原 Nginx，用刚生成的覆盖老的</h3><blockquote><p>注： 虽然这里的备份不是必须的，但是强烈建议备份。这是个好习惯。</p></blockquote><p>复制原来的 Nginx 作为备份。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br></pre></td></tr></table></figure><p>用上个步骤生成的新的 Nginx 程序覆盖老的。<strong>覆盖之前请先停掉你的 Nginx 服务</strong>。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp objs/nginx /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><h3 id="验证配置是否正常"><a href="#验证配置是否正常" class="headerlink" title="验证配置是否正常"></a>验证配置是否正常</h3><p>操作完上面的步骤，我们的 Nginx 就已经重新编译好了，并且增加了 <code>http_ssl_module</code> 模块。不过还是要验证下配置是否正常。如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure><p>如果返回的是如下信息，那么恭喜你，说明一切正常：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure><h3 id="重启你的-Nginx"><a href="#重启你的-Nginx" class="headerlink" title="重启你的 Nginx"></a>重启你的 Nginx</h3><p>重新启动你的 Nginx，检查配置的 <code>http_ssl_module</code> 是否已经生效。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Nginx 信息</span></span><br><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure><p>如果你看到编译参数里面已经增加了 <code>http_ssl_module</code> 模块，那就搞定了。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nginx version: nginx/1.12.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) </span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</span><br></pre></td></tr></table></figure><p>以上，搞定！ 如果帮到你，老板！右下角赏一个？😝</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般在默认安装 Nginx 的时候，&lt;code&gt;http_ssl_module&lt;/code&gt; 模块一般是不会安装的。但是当我们需要在 Nginx 中配置 SSL 的时候，这个模块是必须要安装的。如果配置 SSL 的时候之前没有安装过这个模块，那么不需要重装 Nginx，也是有办法配置这个模块的。接下来就来讲讲怎么在已经安装完的 Nginx 中添加 &lt;code&gt;http_ssl_module&lt;/code&gt; 模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务端" scheme="https://tianxiaohu.online/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="Nginx" scheme="https://tianxiaohu.online/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx + SSL 配置实现 https 访问</title>
    <link href="https://tianxiaohu.online/2020/03/19/server-end/nginx/nginx-https/"/>
    <id>https://tianxiaohu.online/2020/03/19/server-end/nginx/nginx-https/</id>
    <published>2020-03-19T00:36:46.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍如何通过 Nginx 来配置 SSL，开启接口的 https 调用。如果你正在开发微信小程序，那么可能会帮得上忙。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>楼主前阵子写小程序，接口在 Http 环境测试通过，二级域名解析完毕，IP映射完毕，心想万事大吉，发布上线。谁料忘记了小程序生产环境接口必须使用 Https 协议。百密一疏… 看来只能干干运维的活儿了。虽然最后搞定了，不过还是踩了些坑的，记录下。</p><p>所以今天要实现功能就是通过我的二级域名 <code>https://api.tianxiaohu.online</code> 来访问服务器接口。</p><h3 id="你需要准备："><a href="#你需要准备：" class="headerlink" title="你需要准备："></a>你需要准备：</h3><p>这部分不是主要的，所以需要你自行搞定，</p><blockquote><p>· 域名（楼主域名阿里云买的）<br>· 将域名解析到主机IP<br>· 服务器安装好 Nginx 环境（安装时务必安装ssl模块 –with-http_ssl_module，很简单，不会的自行Google）</p></blockquote><h3 id="为你的域名申请-SSL-证书"><a href="#为你的域名申请-SSL-证书" class="headerlink" title="为你的域名申请 SSL 证书"></a>为你的域名申请 SSL 证书</h3><p>为域名申请 SSL 证书其实并不复杂。总所周知，大部分的证书提供商是需要收费的，便宜的也得千把块一年。对于普通个人开发者而言确实是一笔不小的开支。当然了，免费的证书也不是没有，无非就是安全性和稳定性不如收费的。其实平时个人使用还是完全可以 cover 的。<br>如果你使用的是阿里云，那么在阿里云上就有免费的证书可以<a href="https://common-buy.aliyun.com/?spm=5176.2020520163.c1583915649459.d1583915649459_0.d94056a7EtHbw3.d94056a7EtHbw3&commodityCode=cas#/buy" target="_blank" rel="noopener">购买</a>。购买完，按照阿里云的使用文档，为自己的域名申请证书就ok了，不赘述~</p><h3 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h3><p>因为之前你已经域名解析到了你的主机IP，接下来我们需要 Nginx 帮我做的事情就是监听服务器的443端口，然后转发到主机的接口服务上。从而实现通过https访问接口。Nginx具体的安装配置也不过多描述，按照文档来就好，相信不会难倒大家，这里只说一个比较棘手的情况，就是此前已经安装好了Nginx，但是并没有附带安装SSL包。</p><p>这种情况是有办法解决的，可以在不卸载 Nginx 的情况下完成SSL包的配置。详细请看<a href="/2020/03/21/server-end/nginx/nginx-add-ssl-module">《如何为已经安装好的 Nginx 添加 SSL 模块》</a></p><p>开始前先说明下楼主的环境情况（不同环境可能操作有差异）：</p><blockquote><p>· 服务器：CentOS 7.x<br>· 本地机器：MacBook Pro<br>· Nginx 版本：1.12.0<br>· Nginx 安装目录：/usr/local/nginx</p></blockquote><h4 id="1-下载-SSL-证书，存放到服务器"><a href="#1-下载-SSL-证书，存放到服务器" class="headerlink" title="1. 下载 SSL 证书，存放到服务器"></a>1. 下载 SSL 证书，存放到服务器</h4><p>如果你的域名 https 已经开通，那么在对应的平台（我的是阿里云）去下载证书文件。在下载的时候要注意选择对应的服务器类型。有 Tomcat、Apache、IIS、Nginx等，本文主要讲解Nginx，所以选择下载Nginx对应的证书文件到你本地。</p><p>下载后你会得到两个证书文件，假设为 <code>cert.pem</code> 和 <code>cert.key</code>。楼主存放到本地 <code>/Users/Toy/ssl</code> 目录。</p><h4 id="2-将证书文件推送到服务器"><a href="#2-将证书文件推送到服务器" class="headerlink" title="2. 将证书文件推送到服务器"></a>2. 将证书文件推送到服务器</h4><p>下载好的证书需要放置到服务器上，可以自己找个目录存放。楼主这里放到Nginx的安装目录里 <code>/usr/local/nginx/cert/ssl</code>。</p><p>创建证书存放目录（目录可自选）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">mkdir cert</span><br><span class="line">cd cert&#x2F;</span><br><span class="line">mkdir ssl</span><br></pre></td></tr></table></figure><p>推送本地证书文件至服务器新创建的目录：</p><p>推送方法比较多，可以选择使用FTP直接上传，不过需要先在服务器上配置好FTP。楼主比较喜欢简单的 SCP 命令，就是secure copy，是用来进行远程文件拷贝的。数据传输使用 ssh，并且和ssh 使用相同的认证方式，提供相同的安全保证。 </p><p>命令格式：</p><blockquote><p>scp [参数] &lt;源地址（用户名@IP地址或主机名）&gt;:&lt;文件路径&gt; &lt;目的地址（用户名 @IP 地址或主机名）&gt;:&lt;文件路径&gt; </p></blockquote><p>找到之前本地存放证书的目录 <code>/Users/Toy/ssl</code>，然后在终端执行脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp &#x2F;Users&#x2F;Toy&#x2F;ssl&#x2F;cert.pem root@123.123.123.123:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;cert&#x2F;ssl&#x2F;cert.pem</span><br><span class="line">scp &#x2F;Users&#x2F;Toy&#x2F;ssl&#x2F;cert.key root@123.123.123.123:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;cert&#x2F;ssl&#x2F;cert.key</span><br></pre></td></tr></table></figure><p>以上两条命令即可搞定。</p><h4 id="2-开放-443、80-端口"><a href="#2-开放-443、80-端口" class="headerlink" title="2. 开放 443、80 端口"></a>2. 开放 443、80 端口</h4><p>开放端口方法也很多，如果图省事，可以直接在阿里云控制台的安全组里面开放443端口或者80端口。（此方法开启后记得重启服务器，楼主开始也是通过此方法开启，然后一直不生效，坑了我2个小时😓）</p><p>当然也可以通过命令行的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动防火墙</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line">&#x2F;&#x2F; 开启端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;443&#x2F;tcp --permanent</span><br><span class="line">&#x2F;&#x2F; 重启防火墙</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h4 id="3-编辑-nginx-conf-文件，配置-SSL-规则"><a href="#3-编辑-nginx-conf-文件，配置-SSL-规则" class="headerlink" title="3. 编辑 nginx.conf 文件，配置 SSL 规则"></a>3. 编辑 nginx.conf 文件，配置 SSL 规则</h4><p>编辑 nginx.conf</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>配置转发规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 同时监听443和80端口</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    listen       <span class="number">443</span> ssl;</span><br><span class="line">    server_name  api.tianxiaohu.online;</span><br><span class="line">    # 证书目录</span><br><span class="line">    ssl_certificate      /usr/local/nginx/cert/ssl/cert.pem;</span><br><span class="line">    ssl_certificate_key  /usr/local/nginx/cert/ssl/cert.key;</span><br><span class="line">    ssl_session_cache    shared:SSL:<span class="number">1</span>m;</span><br><span class="line">    ssl_session_timeout  <span class="number">5</span>m;</span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers  on;</span><br><span class="line">    # 转发规则</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 服务器接口地址</span><br><span class="line">        proxy_pass http:<span class="comment">//127.0.0.1:8080; </span></span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 Nginx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>如此，如果操作不出意外，那么你就可以开心的使用 https 访问接口了。要不要点个右下角赏一杯咖啡？😃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍如何通过 Nginx 来配置 SSL，开启接口的 https 调用。如果你正在开发微信小程序，那么可能会帮得上忙。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务端" scheme="https://tianxiaohu.online/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
      <category term="Nginx" scheme="https://tianxiaohu.online/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>CSS移动端自适应解决方案</title>
    <link href="https://tianxiaohu.online/2020/02/21/front-end/css/css-responsive/"/>
    <id>https://tianxiaohu.online/2020/02/21/front-end/css/css-responsive/</id>
    <published>2020-02-21T20:00:46.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>都说前端开发苦逼，一大原因就是成天要面对千变万化的手机屏幕尺寸，解决数不尽的兼容性问题。移动端屏幕CSS自适应就是个非常常见的需求，今天就将平时工作中采用的方案分享出来。</p><a id="more"></a><p>其实前端做CSS自适应的方案有很多，这次仅仅介绍一种在自己工作中比较常用的方案。具体步骤如下：</p><h3 id="1-根节点font-size处理逻辑："><a href="#1-根节点font-size处理逻辑：" class="headerlink" title="1. 根节点font-size处理逻辑："></a>1. 根节点<code>font-size</code>处理逻辑：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">designWidth, maxWidth</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doc = <span class="built_in">document</span>, win = <span class="built_in">window</span>, docEl = doc.documentElement, tid;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = docEl.getBoundingClientRect().width;</span><br><span class="line">    maxWidth = maxWidth || <span class="number">540</span>;</span><br><span class="line">    width &gt; maxWidth &amp;&amp; (width = maxWidth);</span><br><span class="line">    <span class="keyword">var</span> rem = (width * <span class="number">100</span>) / designWidth;</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">var</span> actualSize = <span class="built_in">parseFloat</span>(<span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.documentElement)[<span class="string">'font-size'</span>]);</span><br><span class="line">    <span class="keyword">if</span> (actualSize !== rem &amp;&amp; actualSize &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Math</span>.abs(actualSize - rem) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> remScaled = rem * rem / actualSize;</span><br><span class="line">      docEl.style.fontSize = remScaled + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  refreshRem();</span><br><span class="line">  win.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(tid);</span><br><span class="line">    tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">  win.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      clearTimeout(tid);</span><br><span class="line">      tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (doc.readyState === <span class="string">'complete'</span>) &#123;</span><br><span class="line">    doc.body.style.fontSize = <span class="string">'16px'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      doc.body.style.fontSize = <span class="string">'16px'</span>;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">750</span>, <span class="number">750</span>);</span><br></pre></td></tr></table></figure><h3 id="2-在页面引入"><a href="#2-在页面引入" class="headerlink" title="2. 在页面引入"></a>2. 在页面引入</h3><p>将上述代码置于html的 <code>&lt;head&gt;</code> 标签中，优先于页面的css代码加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"><span class="comment">&lt;!-- 此处放上面的代码 --&gt;</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 业务css代码放在后面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编写css代码"><a href="#3-编写css代码" class="headerlink" title="3. 编写css代码"></a>3. 编写css代码</h3><p>配置好后，在css代码中就可以用<code>rem</code>代替<code>px</code>，一般开发中基本都会使用SASS或者LESS，所以可以借助函数来简化我们的开发工作。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义单位处理函数</span><br><span class="line"><span class="keyword">@function</span> p($px) &#123;</span><br><span class="line">    <span class="keyword">@return</span> $px / <span class="number">100</span> * <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 假设设计稿宽度20px</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">P</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后编译成</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0.2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-一劳永逸的方法"><a href="#4-一劳永逸的方法" class="headerlink" title="4. 一劳永逸的方法"></a>4. 一劳永逸的方法</h3><p>其实不难发现，虽然SASS能够减轻我们很多的开发负担，但是每次写<code>p(20)</code>这样的代码还是会浪费很多时间。有没有一劳永逸的方法呢？<br>答案是有的。如果你开发中使用<code>Webpack</code>作为构建工具，那么<code>postcss-plugin-px2rem</code>插件（详见 <a href="https://github.com/pigcan/postcss-plugin-px2rem" target="_blank" rel="noopener" title="插件文档">插件文档</a>)就会是个好的选择。这样你就可以摆脱频繁写css函数的困扰，直接按照设计稿标注的px值来写就好了。</p><p>webpack 可以配置在对应sass文件的loader里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> autoprefixer <span class="keyword">from</span> <span class="string">'autoprefixer'</span>;</span><br><span class="line"><span class="keyword">import</span> px2rem <span class="keyword">from</span> <span class="string">'postcss-plugin-px2rem'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置项</span></span><br><span class="line"><span class="keyword">const</span> px2remOption = &#123;</span><br><span class="line">  rootValue: <span class="number">100</span>,</span><br><span class="line">  unitPrecision: <span class="number">5</span>,</span><br><span class="line">  minPixelValue: <span class="number">0</span>,</span><br><span class="line">  ignoreIdentifier: <span class="string">'no'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> postcssLoader = &#123;</span><br><span class="line">  loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">  query: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      autoprefixer(),</span><br><span class="line">      px2rem(px2remOption)</span><br><span class="line">    ],</span><br><span class="line">    minimize: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简化版webpack配置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        loader: [<span class="string">'css-loader'</span>, postcssLoader, <span class="string">'sass-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，css的写法感觉又回到了我们熟悉的样子，webpack会帮我编译成我们需要的rem单位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 20px就是设计稿标注的尺寸</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是工作中用到的移动端适配方案。希望可以帮到你！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都说前端开发苦逼，一大原因就是成天要面对千变万化的手机屏幕尺寸，解决数不尽的兼容性问题。移动端屏幕CSS自适应就是个非常常见的需求，今天就将平时工作中采用的方案分享出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://tianxiaohu.online/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>javascript 定时器是如何工作的</title>
    <link href="https://tianxiaohu.online/2019/10/04/front-end/javascript/How-JavaScript-Timer-Work/"/>
    <id>https://tianxiaohu.online/2019/10/04/front-end/javascript/How-JavaScript-Timer-Work/</id>
    <published>2019-10-04T20:00:46.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>其实说起JavaScript中的定时器(<em>Timer</em>)中的 <em>setTimeout()</em> 方法，从事开发的同学想必都不会陌生，觉得这些东西很简单很基础。但是有时候恰恰是基础简单的东西，才越容易被忽略。先看一段代码：<br> <a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>如果一眼看出了结果，那稍微改动一下，这样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处仅代表模拟一个耗时运算，这里假设时间大于1秒，</span></span><br><span class="line"><span class="comment">// 便于理解本文的重点，此处不需要过分探究执行时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am run'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>不通过Console控制台运行，能第一时间知道打印的结果么？如果有点不确定，骚年，继续往下看吧。这段代码仔细研究下其实还是蛮有（keng）趣（die）的。个人认为，这也是Javascript语言相比其他编程语言不严谨的地方。当然，为了能够更好的驾驭Javascript这门神奇的语言，这些东西是必须掌握的。</p><h2 id="JS代码是怎么执行的"><a href="#JS代码是怎么执行的" class="headerlink" title="JS代码是怎么执行的"></a>JS代码是怎么执行的</h2><p>那首先应该从JS代码执行说起，JS引擎会在内存中分配堆区（heap）和栈区（stack），那么JS又是以怎样的顺序执行的呢？先看一段很简单的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    B(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newNum = num * num;</span><br><span class="line">    <span class="built_in">console</span>.log(newNum);</span><br><span class="line">&#125;</span><br><span class="line">A();</span><br></pre></td></tr></table></figure><p>当代码运行的时候，为便于理解我们假设栈底有一个main()方法（类似于Java中的入口Main方法）作为运行的开始。</p><p>1.代码开始执行</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/797e315861455afca7ba11e13d9cfa1a.png" alt="第1步"></p><p>2.运行A()方法，将A()入栈，此时A上下文中存在变量 a = 3</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/aefcc296c8a4d0b9f0b8fef7ffd59e13.png" alt="第2步"></p><p>3.调用B()方法，将B()入栈，此时B上下文中存在变量 num = 3，newNum = 9</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/ad890e7e9f1ddde217319a4cce456b8a.png" alt="第3步"></p><p>4.调用B()方法中的console.log()，入栈，控制台打印 9</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/69c0a4dcbe95361966a1b3d5aebe3793.png" alt="第4步"></p><p>5.继续运行，依次将console.log()，和B()方法出栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/6b6ec3ba7b90eb0ad2b1a514d2a6e4d5.png" alt="第5步"></p><p>6.A()方法运行完毕出栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/4ea0f6faf5bfd032ac7915432e614eb8.png" alt="第6步"></p><p>7.代码运行完成，清空栈</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/14/a68daa08f4a97c0f28ec4e6d4ca0bc7d.png" alt="第7步"></p><p>这就是一段简单的代码在堆栈中的执行情况，看明白了就能开始介绍Javascript引擎的另外一个机制。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>众所周知，<strong>Javascript引擎</strong>（以下简称<em>JS引擎</em>）是单线程的，在某一个特定的时间内只能执行一个任务，并阻塞其他任务的执行，也就是说这些任务是串行的。这样的话，用户不得不等待一个耗时的操作完成之后才能进行后面的操作，这显然是不能容忍的，但是实际开发中我们却可以使用异步代码来解决。举个特殊栗子——计算机CPU，我们可以听着音乐的同时愉快的码代码，看起来播放音乐和编辑代码是并行的，其实不然。在计算机中并没有绝对意义上的并行，从微观上来看，单核心的CPU其实在同一个时间片内只能处理单一的任务，一旦某个进程的时间片结束，CPU会马上调度另一个进程执行，先前的进程则处于挂起状态等待获得时间片后继续执行，如此反复，宏观上看起来这些任务就是并行处理的。</p><p>回到我们熟悉的JS引擎，为实现这样的特性，这里就需要引申出一个重要的东西，<em>Event Loop</em>（事件循环）。</p><p>当异步方法比如这里的<strong>setTimeout()</strong>，或者<strong>ajax请求</strong>、<strong>DOM事件执行</strong>的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（<em>task queue</em>）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型。</p><h2 id="SetTimeout"><a href="#SetTimeout" class="headerlink" title="SetTimeout();"></a>SetTimeout();</h2><p>明白了上面的东西，那理解setTimeout的机制就容易得多了。回到开篇的第一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer2</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>为了让大家更直观的看到执行的顺序，做了一个GIF</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/7213bb28fd30caa871d8ef75f425475a.gif" alt="执行步骤gif"></p><p>图上可以看出，首先依然是main()开始，首先第一个console.log()入栈执行，执行完毕控制台打印’start’后出栈，紧接着执行到setTimeout定时器，此时JS引擎会将定时器交给浏览器的另一个模块去管理（为方便理解这里把它叫做Timer模块），然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印’end’，执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印’world’，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印’hello’，清空执行栈，此时任务队列为空，执行结束。</p><p>控制台依次打印出：</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/cebca6ff2376a956c7068066827c6557.png" alt="控制台打印"></p><p>再来看开篇第二段改版代码，就比较好玩了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer2</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处仅代表模拟一个耗时运算，这里假设时间大于1秒，</span></span><br><span class="line"><span class="comment">// 便于理解本文的重点，此处不需要过分探究执行时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Timer3</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I am run'</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure><p>和第一段不同的是，在最后一个定时器前加了一段for循环，（注：此处仅用来模拟一段比较耗时的运算，假设时间大于1秒，代码真正执行时间不必深究）。chrome控制台运行结果是：</p><p><img src="http://n1image.hjfile.cn/mh/2016/12/15/ac2f1caa8cf74b0c699567a66dd59e2b.png" alt="控制台打印"></p><p>前面的那张Gif图看懂了以后，其实从’world’之前的打印应该都是没有问题的。但是奇怪的地方就是，Timer3仅仅延迟了100ms，反而在另外两个Timer之后执行了。其实这里原因很简单，因为在Timer1和Timer2加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Timer1和Timer2并不会得以执行。当for循环结束，这时才将Timer3交由Timer模块去管理，继续执行后续代码打印’end’，清空执行栈。虽然在这里Timer3的延迟时间最短，但是加入任务队列后还是会排在Timer1和Timer2的后面，所以此时按顺序执行任务队列中的代码，依次打印’hello’、’world’、’I am run’。同时需要注意的是，这种情况下的三个定时器延迟执行的时间已经远远超过了指定的时间。</p><p>还有一点值得特别注意的是，有些同学可能会写过这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其实JS引擎在处理这段代码的时候，并不是真正的延迟0ms执行。不同的浏览器会默认有一个最小的延迟时间，低于这个时间间隔会按照默认最小的时间间隔来处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们发现不论事件循环（_Event Loop_）模型还是setTimeout机制，其实并不是难点，但却是很多开发同学容易忽略的点。很多问题的产生可能就是因为忽略了一些简单的原理导致的。所以这些基本的知识点需要掌握扎实，才能更好的驾驭Javascript。如果有兴趣可以翻墙看一看下面参考中的视频，强烈推荐！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">Philip Roberts: What the heck is the event loop anyway?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实说起JavaScript中的定时器(&lt;em&gt;Timer&lt;/em&gt;)中的 &lt;em&gt;setTimeout()&lt;/em&gt; 方法，从事开发的同学想必都不会陌生，觉得这些东西很简单很基础。但是有时候恰恰是基础简单的东西，才越容易被忽略。先看一段代码：&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 中实现位数字添加千分位</title>
    <link href="https://tianxiaohu.online/2019/06/11/front-end/javascript/qian-fen-wei/"/>
    <id>https://tianxiaohu.online/2019/06/11/front-end/javascript/qian-fen-wei/</id>
    <published>2019-06-11T20:30:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊一个比较有意思的问题，就是在 JavaScript 中为数字添加千分位。这种在一些需要显示金额的地方可能会用到。今天我们来探索几种不同的方法。</p><a id="more"></a><h1 id="解法一：toLocaleString"><a href="#解法一：toLocaleString" class="headerlink" title="解法一：toLocaleString()"></a>解法一：toLocaleString()</h1><p>我们先看一种比较简单的方法，代码行数最少。numObj.toLocaleString([locales [, options]])</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1234567</span>;</span><br><span class="line"><span class="keyword">const</span> str = num.toLocaleString()</span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 1,234,567</span></span><br></pre></td></tr></table></figure><p>不过需要注意的是，使用前需要先关注下各个浏览器的兼容性情况。</p><h2 id="解法二：正则"><a href="#解法二：正则" class="headerlink" title="解法二：正则"></a>解法二：正则</h2><p>正则是我个人比较喜欢的一种方式，代码量少并且执行效率较高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="string">'10000000000'</span>;</span><br><span class="line"><span class="keyword">const</span> result = num.replace(<span class="regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">'$&amp;,'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 10,000,000,000</span></span><br></pre></td></tr></table></figure><p>不过上面的这种正则不支持数字里面带小数点。如果带有小数点的可能需要额外处理下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="string">'12345678.01'</span>;</span><br><span class="line"><span class="keyword">const</span> [left, right] = num.split(<span class="string">'.'</span>);</span><br><span class="line"><span class="keyword">const</span> result = <span class="string">`<span class="subst">$&#123;left.replace(<span class="regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">'$&amp;,'</span>)&#125;</span>.<span class="subst">$&#123;right&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 12,345,678.01</span></span><br></pre></td></tr></table></figure><h2 id="解法三：for-循环"><a href="#解法三：for-循环" class="headerlink" title="解法三：for 循环"></a>解法三：for 循环</h2><p>通过循环的方式，自然是最符合程序猿思维的方式了。不过相比较上面的两种方式代码量就比较多了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> numStr = <span class="string">`<span class="subst">$&#123;num&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = numStr.length - <span class="number">1</span>, j = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--, j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j%<span class="number">3</span> === <span class="number">0</span> &amp;&amp; i !== <span class="number">0</span>)&#123;</span><br><span class="line">      str += <span class="string">`<span class="subst">$&#123;numStr[i]&#125;</span>,`</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str += numStr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法四：reduce-版本"><a href="#解法四：reduce-版本" class="headerlink" title="解法四：reduce 版本"></a>解法四：reduce 版本</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> numStr = <span class="string">`<span class="subst">$&#123;num&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">return</span> numStr.split(<span class="string">''</span>).reverse().reduce(<span class="function">(<span class="params">prev, next, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((index % <span class="number">3</span>) ? next : <span class="string">`<span class="subst">$&#123;next&#125;</span>,`</span>) + prev;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈  just for fun!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天聊一个比较有意思的问题，就是在 JavaScript 中为数字添加千分位。这种在一些需要显示金额的地方可能会用到。今天我们来探索几种不同的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中 this 的绑定规则</title>
    <link href="https://tianxiaohu.online/2018/06/27/front-end/javascript/javascript-this/"/>
    <id>https://tianxiaohu.online/2018/06/27/front-end/javascript/javascript-this/</id>
    <published>2018-06-27T21:08:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>javascript 中的 <code>this</code> 有时候是比较魔幻的一个存在，在 JavaScript 中 this 有几种常见的绑定方式，今天就来详细的介绍一下。</p><a id="more"></a><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>默认绑定 this 指向全局对象，但是在严格模式下，即：‘use strict’ ，this 会被绑定成 undefined。</p><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>当函数引用有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。</p><h2 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h2><p>很多函数提供了可选参数，来制定上下文。比如 Array 的 forEach 方法 <code>arr.forEach(fun, context)</code>，context 指定了函数 fun 的上下文对象。通过 call、apply 或者 bind 这些函数，可以显示的指定函数的上下文环境。</p><p>注意：把 <code>null</code>或者 <code>undefined</code> 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略。</p><p>call 和 apply 的区别在于，<code>call</code> 方法接受的是若干个参数的列表，而 <code>apply</code> 方法接受的是一个包含多个参数的数组。</p><p>call apply 的使用方法举例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断数组： </span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组最大值:</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span> ]; </span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, numbers);   <span class="comment">//458</span></span><br></pre></td></tr></table></figure><h3 id="实现-call-ctx-arg1-arg2-…"><a href="#实现-call-ctx-arg1-arg2-…" class="headerlink" title="实现 call(ctx, arg1, arg2 …)"></a>实现 call(ctx, arg1, arg2 …)</h3><p>简单版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此时环境中 context就是目标上下文，this就是原来的函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">// foo.fn = bar</span></span><br><span class="line">    context.fn();<span class="comment">// foo.fn()</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;<span class="comment">// delete foo.fn</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>复杂版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-apply-ctx-arg1-arg2-…"><a href="#实现-apply-ctx-arg1-arg2-…" class="headerlink" title="实现 apply(ctx, [arg1, arg2 …])"></a>实现 apply(ctx, [arg1, arg2 …])</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span>; </span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.fn(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>还有一种 this 的绑定方式就是通过 <code>new</code> 操作符。new 会将构造函数的this指向该对象。</p><h2 id="箭头函数绑定"><a href="#箭头函数绑定" class="headerlink" title="箭头函数绑定"></a>箭头函数绑定</h2><p>最后一种就是在箭头函数中的绑定。箭头函数 this 绑定有以下特点：</p><ol><li>箭头函数不绑定 this，箭头函数中的 this 相当于普通变量。</li><li>箭头函数的this寻值行为与普通变量相同，在作用域中逐级寻找。</li><li>箭头函数的this无法通过bind，call，apply来直接修改（可以间接修改）。</li><li>改变作用域中this的指向可以改变当前作用域中的箭头函数的this。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript 中的 &lt;code&gt;this&lt;/code&gt; 有时候是比较魔幻的一个存在，在 JavaScript 中 this 有几种常见的绑定方式，今天就来详细的介绍一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手动实现 jsonp 解决跨域问题</title>
    <link href="https://tianxiaohu.online/2018/05/23/front-end/javascript/javascript-jsonp/"/>
    <id>https://tianxiaohu.online/2018/05/23/front-end/javascript/javascript-jsonp/</id>
    <published>2018-05-23T20:06:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>前端跨域是一个老生常谈的话题，解决跨域的方式有很多种，<code>jsonp</code> 就是其中的一种。今天就来简单实现一个 <code>jsonp</code></p><a id="more"></a><h2 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h2><p>通俗易懂的说，跨域就是一个域下面的脚本去请求另一个域下面的资源，就成为跨域。不过这种说法是比较广义的说法。</p><p>平时前端开发中所说的跨域，一般指的是由浏览器的一种安全策略 —— “同源策略” 所导致的。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。<br>如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p><h2 id="常见的解决跨域的方法"><a href="#常见的解决跨域的方法" class="headerlink" title="常见的解决跨域的方法"></a>常见的解决跨域的方法</h2><p>在前端的开发中，跨域应该是最司空见惯的问题。解决跨域其实方法有很多种，常用的方法有：</p><ul><li>通过jsonp跨域</li><li>document.domain + iframe跨域</li><li>postMessage跨域</li><li>nginx代理跨域</li><li>nodejs中间件代理跨域</li></ul><p>等等…</p><h2 id="jsonp-跨域方案"><a href="#jsonp-跨域方案" class="headerlink" title="jsonp 跨域方案"></a>jsonp 跨域方案</h2><p>从上面可以知道，其实实际开发中解决跨域的方案有很多种。不过我们这次只介绍 <code>jsonp</code> 这种方案。<br>直接上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, document</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">var</span> jsonp = <span class="function"><span class="keyword">function</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dataString = url.indexof(<span class="string">"?"</span>) === <span class="number">-1</span> ? <span class="string">"?"</span> : <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      dataString += key + <span class="string">"="</span> + data[key] + <span class="string">"&amp;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cbFuncName = <span class="string">"my_json_cb_"</span> + <span class="built_in">Math</span>.random().toString().replace(<span class="string">"."</span>, <span class="string">""</span>);</span><br><span class="line">    dataString += <span class="string">"callback="</span> + cbFuncName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    scriptEle.src = url + dataString;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>[cbFuncName] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      callback(data);</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(scriptEle);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.$jsonp = jsonp;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><p>上面的代码没有使用目前流行的ES6语法，目的是方便使用。不过目前开发都是使用babel编译的，可以自行将代码转换为ES6语法，这样看起来更舒服一点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端跨域是一个老生常谈的话题，解决跨域的方式有很多种，&lt;code&gt;jsonp&lt;/code&gt; 就是其中的一种。今天就来简单实现一个 &lt;code&gt;jsonp&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 深拷贝 vs 浅拷贝</title>
    <link href="https://tianxiaohu.online/2018/03/08/front-end/javascript/javascript-copy/"/>
    <id>https://tianxiaohu.online/2018/03/08/front-end/javascript/javascript-copy/</id>
    <published>2018-03-08T22:12:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的深拷贝与浅拷贝</p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在讲深拷贝和浅拷贝之前，我们先来重新回顾一下 JavaScript 中的数据类型。 在JavaScript中，数据的类型大体可以分为两类：<code>基本数据类型</code> 和 <code>引用类型</code>。</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>基本数据类型就很好理解了，常见的 <code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>null</code> 等这些都是基本数据类型。<br>基本类型是存储在内存的 <code>栈</code> 中，直接按照值来存放。需要注意的是：基本类型的值是不可改变的。</p><p>就拿 <code>字符串类型</code> 来说。我们知道在 Java 是一种强类型语言，在 Java 中，<code>String</code> 类型是 Public final 修饰的，也就是说是一个不可变类，在Java中字符串一旦创建，就不会在被更改。</p><p>虽然 JavaScript 是弱类型的语言，但是在字符串方面还是和 java 保持一致的。在 JavaScript 中，<code>string</code> 字符串同样也是不可变的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">"Java"</span>;</span><br><span class="line">lang = lang + <span class="string">"Script"</span>;</span><br></pre></td></tr></table></figure><p>如上，虽然 <code>lang</code> 被初始赋值成 <code>Java</code> 后又重新指向了新的 <code>JavaScript</code>，但是在内存中，并不是简单的将 <code>Java</code> 字符串修改成 <code>Javascript</code>，而是重新创建新的字符串。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型是存放在内存 <code>堆</code> 中。比如常见的 对象、数组、函数都属于引用类型。变量实质上存放的是该对象在 <code>堆</code> 中的一个地址。</p><p>与基本类型不同的是，引用类型的值是可以改变的，改变的其实也是其在堆内存中的地址值。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝就是只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存。<br>常见的浅拷贝操作有：</p><p>Object.assign、展开语法 “…”、Array.prototype.slice 等等。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变，这称之为深拷贝。</p><p>常见的第三方库 <code>JQuery</code> <code>lodash</code> 都提供有深拷贝的 api。</p><p>最简单的实现深拷贝的方法就是利用 JSON.parse</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure><p>不过这种方式有局限：</p><ol><li>会忽略 undefined</li><li>会忽略 symbol</li><li>不能序列化函数</li><li>不能解决循环引用的对象</li><li>不能正确处理new Date()</li><li>不能处理正则</li></ol><h2 id="简单实现深拷贝"><a href="#简单实现深拷贝" class="headerlink" title="简单实现深拷贝"></a>简单实现深拷贝</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">typeof</span> source === <span class="string">'object'</span> &amp;&amp; source != <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> source; <span class="comment">// 非对象返回自身</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">var</span> prop = source[key];</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> prop === <span class="string">'object'</span> &amp;&amp; prop != <span class="literal">null</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep(prop); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 中的深拷贝与浅拷贝&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何模拟实现 Promise.all</title>
    <link href="https://tianxiaohu.online/2017/09/17/front-end/javascript/promise-all/"/>
    <id>https://tianxiaohu.online/2017/09/17/front-end/javascript/promise-all/</id>
    <published>2017-09-17T23:09:46.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>在开始之前，我们先看下 Promise.all() 方法的定义。<br>Promise.all() 方法接收一个 <code>promise</code> 的 <code>iterable</code> 类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个Promise实例，<br>那个输入的所有promise的resolve回调的结果是一个数组。这个 Promise 的 resolve 回调执行是在所有输入的promise的resolve回调都结束，<br>或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p> <a id="more"></a><h2 id="Promise-all-的使用"><a href="#Promise-all-的使用" class="headerlink" title="Promise.all 的使用"></a>Promise.all 的使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3])</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// [1, 2, 3]  </span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="模拟实现一个-Promise-all"><a href="#模拟实现一个-Promise-all" class="headerlink" title="模拟实现一个 Promise.all"></a>模拟实现一个 Promise.all</h2><p>从 Promise.all 的定义我们可以知道，Promise.all 具有这样的特点：</p><ul><li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象，</li><li>如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象</li><li>如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调</li><li>只要有一个失败，状态就变为 rejected，返回值将直接传递给回调 all() 的返回值也是新的 Promise 对象</li></ul><p>那么我们尝试来实现下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAll</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">(resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument must be an array'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> promiseLen = promises.length;</span><br><span class="line">    <span class="comment">// 用来接收结果的数组</span></span><br><span class="line">    <span class="keyword">let</span> resolveValues = [];</span><br><span class="line">    <span class="comment">// 定一个变量记录resolve的promise的数量</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseLen; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i])</span><br><span class="line">        .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          counter++;</span><br><span class="line">          resolveValues[i] = data;</span><br><span class="line">          <span class="comment">// 当所有promise resolve后，整个promise resolve</span></span><br><span class="line">          <span class="keyword">if</span> (counter === promiseLen) &#123;</span><br><span class="line">            resolve(resolveValues);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个较为简单的模拟 Promise.all 的方法。欢迎大家讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开始之前，我们先看下 Promise.all() 方法的定义。&lt;br&gt;Promise.all() 方法接收一个 &lt;code&gt;promise&lt;/code&gt; 的 &lt;code&gt;iterable&lt;/code&gt; 类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个Promise实例，&lt;br&gt;那个输入的所有promise的resolve回调的结果是一个数组。这个 Promise 的 resolve 回调执行是在所有输入的promise的resolve回调都结束，&lt;br&gt;或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>实现 Promise finally</title>
    <link href="https://tianxiaohu.online/2017/09/11/front-end/javascript/javascript-promise-finally/"/>
    <id>https://tianxiaohu.online/2017/09/11/front-end/javascript/javascript-promise-finally/</id>
    <published>2017-09-11T19:42:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>给 <code>Promise</code> 实现 <code>finally</code> 方法</p><a id="more"></a><p>废话不多说，比较简单，直接上代码吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给 &lt;code&gt;Promise&lt;/code&gt; 实现 &lt;code&gt;finally&lt;/code&gt; 方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>在 JavaScript 中 new 发生了什么？</title>
    <link href="https://tianxiaohu.online/2017/07/11/front-end/javascript/javascript-new/"/>
    <id>https://tianxiaohu.online/2017/07/11/front-end/javascript/javascript-new/</id>
    <published>2017-07-11T23:13:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在 JavaScript 中可以通过 new 操作符来实例化一个对象。那么，在JavaScript的底层，new 做了什么事情呢？</p><a id="more"></a><h2 id="new-发生了什么"><a href="#new-发生了什么" class="headerlink" title="new 发生了什么"></a>new 发生了什么</h2><ol><li>首先创建了一个对象。</li><li>构造该对象的 <code>_proto_</code> 属性。</li><li>将构造函数的上下文 <code>this</code> 指向该对象，并执行构造函数。</li><li>返回新对象</li></ol><h2 id="简单实现一个-new"><a href="#简单实现一个-new" class="headerlink" title="简单实现一个 new"></a>简单实现一个 <code>new</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create();</span><br><span class="line">    <span class="comment">// 获得传入的构造函数，取arguments剩余参数作为参数。</span></span><br><span class="line">    <span class="keyword">let</span> Con = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 绑定对象的proto</span></span><br><span class="line">    obj._proto_ = Con.prototype;</span><br><span class="line">    <span class="comment">// 调用构造函数，指定this为obj</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 返回新对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用内置的new</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'Toy'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 使用我们自己的方法</span></span><br><span class="line"><span class="keyword">const</span> person2 = myNew(Person, <span class="string">'Toy'</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，在 JavaScript 中可以通过 new 操作符来实例化一个对象。那么，在JavaScript的底层，new 做了什么事情呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>node中的path</title>
    <link href="https://tianxiaohu.online/2017/05/18/front-end/node/path-vs-fs/"/>
    <id>https://tianxiaohu.online/2017/05/18/front-end/node/path-vs-fs/</id>
    <published>2017-05-18T20:00:46.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>path 模块提供了一些工具函数，用于处理文件与目录的路径<br> <a id="more"></a></p><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>path 模块提供了一些工具函数，用于处理文件与目录的路径<br> <!-- more --></p><h2 id="1-path-basename-path-ext"><a href="#1-path-basename-path-ext" class="headerlink" title="1. path.basename(path[, ext])"></a>1. path.basename(path[, ext])</h2><p>path.basename() 方法返回一个 path 的最后一部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; ccc.html</span><br></pre></td></tr></table></figure><h2 id="2-path-dirname-path"><a href="#2-path-dirname-path" class="headerlink" title="2. path.dirname(path)"></a>2. path.dirname(path)</h2><p>path.dirname() 方法返回一个 path 的目录名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; <span class="regexp">/aaa/</span>bbb</span><br></pre></td></tr></table></figure><h2 id="3-path-extname-path"><a href="#3-path-extname-path" class="headerlink" title="3. path.extname(path)"></a>3. path.extname(path)</h2><p>path.extname() 方法返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（见 path.basename()）的第一个字符是 .，则返回一个空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.basename(<span class="string">'/aaa/bbb/ccc.html'</span>);</span><br><span class="line">=&gt; .html</span><br></pre></td></tr></table></figure><h2 id="4-path-join-…paths"><a href="#4-path-join-…paths" class="headerlink" title="4. path.join([…paths])"></a>4. path.join([…paths])</h2><p>path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'/a'</span>,<span class="string">'b'</span>);             =&gt; <span class="string">'/a/b'</span></span><br><span class="line">path.join(<span class="string">'/a'</span>,<span class="string">'b'</span>, <span class="string">'..'</span>, <span class="string">'c'</span>)   =&gt; <span class="string">'/a/c'</span></span><br></pre></td></tr></table></figure><h2 id="5-path-relative-from-to"><a href="#5-path-relative-from-to" class="headerlink" title="5. path.relative(from, to)"></a>5. path.relative(from, to)</h2><p>path.relative() 方法返回从 from 到 to 的相对路径，通俗点将就是，从from为起点，to相对于它的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.relative(<span class="string">'/a/b/c/test'</span>, <span class="string">'/a/b/d/test2'</span>);</span><br><span class="line">=&gt; <span class="string">'../../d/test2'</span></span><br></pre></td></tr></table></figure><h2 id="6-path-resolve-…paths"><a href="#6-path-resolve-…paths" class="headerlink" title="6. path.resolve([…paths])"></a>6. path.resolve([…paths])</h2><p>path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径后返回。如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'/a/b'</span>, <span class="string">'./test'</span>);             =&gt; <span class="regexp">/a/</span>b/test</span><br><span class="line">path.resolve(<span class="string">'a'</span>, <span class="string">'b/c/'</span>, <span class="string">'../d/test'</span>);     =&gt; <span class="regexp">/home/</span>toy/a/b/d/test</span><br></pre></td></tr></table></figure><h1 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h1><h2 id="1-fs-open-path-flags-mode-callback"><a href="#1-fs-open-path-flags-mode-callback" class="headerlink" title="1. fs.open(path, flags[, mode], callback)"></a>1. fs.open(path, flags[, mode], callback)</h2><p>异步地打开文件,callback有两个参数 err和fd  fd是返回的文件描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r'</span>, <span class="string">'0666'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fd);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-fs-read-fd-buffer-offset-length-position-callback"><a href="#2-fs-read-fd-buffer-offset-length-position-callback" class="headerlink" title="2. fs.read(fd, buffer, offset, length, position, callback)"></a>2. fs.read(fd, buffer, offset, length, position, callback)</h2><p>从 fd 指定的文件中读取数据。<br>buffer 是数据将被写入到的 buffer。<br>offset 是 buffer 中开始写入的偏移量。<br>length 是一个整数，指定要读取的字节数。<br>position 是一个整数，指定从文件中开始读取的位置。 如果 position 为 null，则数据从当前文件位置开始读取。</p><h2 id="3-fs-readFile-file-options-callback"><a href="#3-fs-readFile-file-options-callback" class="headerlink" title="3. fs.readFile(file[, options], callback)"></a>3. fs.readFile(file[, options], callback)</h2><p>异步的读取一个文件的全部内容,如果字符编码未指定，则返回原始的 buffer。它是对read方法的一个进一步封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="Demo-读取文件"><a href="#Demo-读取文件" class="headerlink" title="Demo - 读取文件"></a>Demo - 读取文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.alloc(<span class="number">255</span>);</span><br><span class="line">    fs.read(fd, buf, <span class="number">0</span>, <span class="number">6</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, byteRead, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(byteRead); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="built_in">console</span>.log(buffer.toString());   <span class="comment">// 被读取的缓存区buffer</span></span><br><span class="line">        fs.close(fd, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="4-fs-write-fd-data-position-encoding-callback"><a href="#4-fs-write-fd-data-position-encoding-callback" class="headerlink" title="4. fs.write(fd, data[, position[, encoding]], callback)"></a>4. fs.write(fd, data[, position[, encoding]], callback)</h2><p>写入 data 到 fd 指定的文件。 如果 data 不是一个 Buffer 实例，则该值将被强制转换为一个字符串。<br>position 指向从文件开始写入数据的位置的偏移量，encoding 是期望的字符串编码。回调有三个参数 (err, written, string)，其中 written 指定传入的字符串被写入多少字节</p><p>在 Linux 上，当文件以追加模式打开时，指定位置的写入是不起作用的。 内核会忽略位置参数，并总是将数据追加到文件的末尾。</p><h2 id="5-fs-writeFile-file-data-options-callback"><a href="#5-fs-writeFile-file-data-options-callback" class="headerlink" title="5. fs.writeFile(file, data[, options], callback)"></a>5. fs.writeFile(file, data[, options], callback)</h2><p>异步地写入数据到文件，如果文件已经存在，则写入的内容会替换原有的内容，没有则创建文件。 data 可以是一个字符串或一个 buffer。如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’。</p><p>它是对write方法的进一步封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'./a.txt'</span>, <span class="string">'Hello Node.js'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'write finshed!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><blockquote><p>fs.write()和fs.writeFile()方法的比较(同read)</p></blockquote><p>与fs.readFile()方法和fs.read()方法的关系类似。fs.writeFile()也是对fs.write()方法的进一步封装，使用fs.readFile()方法省略了创建文件描述符的过程，可以更方便的向文件写入数据。</p><blockquote><p>fs.close() 打开的文件最后需要及时关掉</p></blockquote><p>其实如果不调用close()并不会立即抛出异常，但是Node对同时打开的文件数量是有限制的。如果你不停的open一个文件而不close，最后将会抛出异常：EMFILE: too many open files error.</p><hr><h2 id="6-fs-appendFile-file-data-options-callback"><a href="#6-fs-appendFile-file-data-options-callback" class="headerlink" title="6. fs.appendFile(file, data[, options], callback)"></a>6. fs.appendFile(file, data[, options], callback)</h2><p>异步地追加数据到一个文件，如果文件不存在则创建文件。 data 可以是一个字符串或 buffer。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.appendFile(<span class="string">'./a.txt'</span>, <span class="string">', Hello Hujiang!'</span>, (err) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'append complete!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="Demo-写入内容到文件"><a href="#Demo-写入内容到文件" class="headerlink" title="Demo - 写入内容到文件"></a>Demo - 写入内容到文件</h2><p>注意此时应该用读写模式打开文件，否则写入不成功，会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r+'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.from(<span class="string">'Nodejs好牛逼'</span>);</span><br><span class="line">    <span class="comment">//只写入“好牛逼”这三个字</span></span><br><span class="line">    fs.write(fd, buf, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(written); <span class="comment">// 实际读取的字节数</span></span><br><span class="line">        <span class="built_in">console</span>.log(buffer.toString());   <span class="comment">// 被读取的缓存区buffer</span></span><br><span class="line">        fs.close(fd, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>刷新缓存区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./a.txt'</span>, <span class="string">'r+'</span>, (err, fd) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> buf = Buffer.from(<span class="string">'Nodejs好牛逼'</span>);</span><br><span class="line">    <span class="comment">//只写入“好牛逼”这三个字</span></span><br><span class="line">    fs.write(fd, buf, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(written); <span class="comment">// 实际写入的字节数</span></span><br><span class="line">        fs.write(fd, buf, <span class="number">6</span>, <span class="number">6</span>, <span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, written, buffer</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(written);</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;path 模块提供了一些工具函数，用于处理文件与目录的路径&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node" scheme="https://tianxiaohu.online/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>IOS ( Safari ) 返回页面不刷新如何解决？</title>
    <link href="https://tianxiaohu.online/2017/04/11/front-end/javascript/ios-back-fix/"/>
    <id>https://tianxiaohu.online/2017/04/11/front-end/javascript/ios-back-fix/</id>
    <published>2017-04-11T22:39:00.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>在平时开发移动端项目的时候，是否被<code>IOS</code>或者部分<code>Android</code>浏览器返回页面不刷新的问题困扰过？这个问题应该比较常见的一个问题。</p><a id="more"></a><p>比如一个典型的场景：页面未登录，点击页面某个按钮后跳转公共的登录页面完成登录后，点击浏览器返回按钮。返回到上个页面，发现页面直接从缓存读取，并没有刷新，导致最新的登录态无法获得。当然了，如果是单页应用，登录页面是前端的<code>router</code><br>自然是没这个问题了。</p><p>如果是非单页，通过<code>location.href</code>的方式跳走再返回这种情况该如何处理呢？</p><h2 id="PageTransitionEvent-persisted"><a href="#PageTransitionEvent-persisted" class="headerlink" title="PageTransitionEvent.persisted"></a>PageTransitionEvent.persisted</h2><p>那既然是因为读取了缓存导致，如果可以判断是不是走了缓存，岂不是就能解决问题？答案是可行的！</p><p><code>PageTransitionEvent</code> 的只读属性 <code>persisted</code> 代表一个页面是否从缓存中加载的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.persisted) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Page was loaded from cache.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在页面展示的时候判断是不是走了缓存，如果是，那就重新刷新页面。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browserRule = <span class="regexp">/^.*((iPhone)|(iPad)|(Safari))+.*$/</span>;</span><br><span class="line"><span class="keyword">if</span> (browserRule.test(navigator.userAgent)) &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.persisted) &#123;</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上大部分情况都是IOS才会有这个问题，注意判断下设备是IOS设备再添加此代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时开发移动端项目的时候，是否被&lt;code&gt;IOS&lt;/code&gt;或者部分&lt;code&gt;Android&lt;/code&gt;浏览器返回页面不刷新的问题困扰过？这个问题应该比较常见的一个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>debounce &amp; throttle</title>
    <link href="https://tianxiaohu.online/2017/01/14/front-end/javascript/debounce-vs-throttle/"/>
    <id>https://tianxiaohu.online/2017/01/14/front-end/javascript/debounce-vs-throttle/</id>
    <published>2017-01-14T20:00:46.000Z</published>
    <updated>2021-08-09T06:35:13.236Z</updated>
    
    <content type="html"><![CDATA[<p>记录下个人对防抖函数和节流函数的理解，在高频触发的事件中，较为实用。<br> <a id="more"></a></p><h2 id="debounce-func-wait-0-options"><a href="#debounce-func-wait-0-options" class="headerlink" title="_.debounce (func, [wait=0], [options])"></a>_.debounce (func, [wait=0], [options])</h2><p>创建一个防抖动函数。该函数会在 wait 毫秒后调用 func 方法。该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。可以提供一个 options 对象决定如何调用 func 方法，options.leading 和 options.trailing 决定延迟前后如何触发。func 会传入最后一次传入的参数给防抖动函数。随后调用的防抖动函数返回是最后一次 func 调用的结果。</p><p>个人理解:</p><ul><li><p>wait = 400, leading = false, trailing = true<br>函数不会立即执行，当事件连续触发或两次触发间隔小于400ms的时候函数不会执行，直到事件停止触发且隔时间大于400ms，函数执行一次。若间隔时间小于400ms时再次触发事件，则函数执行时间重新开始计算。</p></li><li><p>wait = 400, leading = true, trailing = false<br>函数先立即执行一次，当事件连续触发或两次触发间隔小于400ms的时候函数不会执行，只有当事件停止触发且间隔时间大于400ms时，函数才会变成可执行状态（此时并不会自动自动触发），此时再次触发事件，函数会立即执行一次。</p></li><li><p>wait = 400, leading = true, trailing = true<br>如果都设为true的话，其实效果是相当于两个的结合，函数首先会执行一次，</p></li></ul><p>场景1：页面resize时候，显示窗口大小<br>场景2：实时动态搜索框</p><p>换一种方式实现Debounce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throttle-func-wait-0-options"><a href="#throttle-func-wait-0-options" class="headerlink" title="_.throttle (func, [wait=0], [options])"></a>_.throttle (func, [wait=0], [options])</h2><p>创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。该函数提供一个 cancel 方法取消延迟函数调用以及 flush 方法立即调用。可以提供一个 options 对象决定如何调用 func 方法，options.leading 和 options.trailing 决定 wait 前后如何触发。func 会传入最后一次传入的参数给这个函数。随后调用的函数返回是最后一次 func 调用的结果。</p><p>注意: 如果 leading 和 trailing 都设定为 true。 则 func 允许 trailing 方式调用的条件为: 在 wait 期间多次调用。</p><p>相当于是给的bounce方法指定参数： maxWait、leading=true、trailing=true</p><p>场景1：页面缩放始终保持弹窗居中显示<br>场景2：下拉加载</p><p>换一种简单的方式实现Throttle</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>,</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流和防抖区别"><a href="#节流和防抖区别" class="headerlink" title="节流和防抖区别"></a>节流和防抖区别</h2><p>最大的不同，通俗点说就是Debounce的函数可能很久都不会执行一次，但是Throttle的函数则保证了在给定的wait时间内肯定会执行一次，保证了函数的执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下个人对防抖函数和节流函数的理解，在高频触发的事件中，较为实用。&lt;br&gt;
    
    </summary>
    
    
      <category term="web前端" scheme="https://tianxiaohu.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://tianxiaohu.online/tags/JavaScript/"/>
    
  </entry>
  
</feed>
